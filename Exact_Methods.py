# -*- coding: utf-8 -*-
"""Method_Exact.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rUk8tpNKUvXWn2XBdndYT7m-GtcgJLKs
"""

def order_jobs_in_descending_order_of_total_completion_time(processing_times):
    total_completion_time = processing_times.sum(axis=1)
    return np.argsort(total_completion_time, axis=0).tolist()

def insertion(sequence, position, value):
    new_seq = sequence[:]
    new_seq.insert(position, value)
    return new_seq
def neh_algorithm(processing_times):
    ordered_sequence = order_jobs_in_descending_order_of_total_completion_time(processing_times)
    # Define the initial order
    J1, J2 = ordered_sequence[:2]
    sequence = [J1, J2] if evaluate_sequence([J1, J2], processing_times) < evaluate_sequence([J2, J1], processing_times) else [J2, J1]
    del ordered_sequence[:2]
    # Add remaining jobs
    for job in ordered_sequence:
        Cmax = float('inf')
        best_sequence = []
        for i in range(len(sequence)+1):
            new_sequence = insertion(sequence, i, job)
            Cmax_eval = evaluate_sequence(new_sequence, processing_times)
            if Cmax_eval < Cmax:
                Cmax = Cmax_eval
                best_sequence = new_sequence
        sequence = best_sequence
    return sequence, Cmax
# Define the Node structure of the seach tree that we will be using
class Node:
    def __init__(self, jobs, remaining_jobs, parent=None, lower_bound=1e100):
        self.jobs = jobs
        self.remaining_jobs = remaining_jobs
        self.parent = parent
        self.lower_bound = lower_bound
    def __str__(self):
        return f"Node(jobs={self.jobs}, remaining_jobs={self.remaining_jobs}, lower_bound={self.lower_bound})"
    def __lt__(self, other):
        # Define less than comparison for the priority queue
        return self.lower_bound < other.lower_bound

    def __eq__(self, other):
        # Define equality for the priority queue
        return self.lower_bound == other.lower_bound
def evaluate_sequence(sequence, processing_times):
    _, num_machines = processing_times.shape
    num_jobs = len(sequence)

    # Check if the sequence is empty
    if num_jobs == 0:
        # Return a default value (you may choose 0 or another suitable value)
        return 0

    completion_times = np.zeros((num_jobs, num_machines))

    # Calculate the completion times for the first machine
    completion_times[0][0] = processing_times[sequence[0]][0]
    for i in range(1, num_jobs):
        completion_times[i][0] = completion_times[i-1][0] + processing_times[sequence[i]][0]

    # Calculate the completion times for the remaining machines
    for j in range(1, num_machines):
        completion_times[0][j] = completion_times[0][j-1] + processing_times[sequence[0]][j]
        for i in range(1, num_jobs):
            completion_times[i][j] = max(completion_times[i-1][j], completion_times[i][j-1]) + processing_times[sequence[i]][j]

    # Return the total completion time, which is the completion time of the last job in the last machine
    return completion_times[num_jobs-1][num_machines-1]
import numpy as np

def job_completion_times(jobs_matrix, sequence):
    num_jobs, num_machines = jobs_matrix.shape
    completion_matrix = np.zeros((len(sequence), num_machines))

    for i in range(len(sequence)):
        for j in range(num_machines):
            if i == 0 and j == 0:
                completion_matrix[0, j] = jobs_matrix[sequence[i], j]
            elif i == 0:
                completion_matrix[0, j] = jobs_matrix[sequence[i], j] + completion_matrix[0, j - 1]
            elif j == 0:
                completion_matrix[i, 0] = jobs_matrix[sequence[i], j] + completion_matrix[i - 1, 0]
            else:
                completion_matrix[i, j] = jobs_matrix[sequence[i], j] + max(completion_matrix[i - 1, j], completion_matrix[i, j - 1])

    return completion_matrix
def fist_lower_baund(processing_times, column_sums, lign_sums):
    lb1 = column_sums[0] + min(lign_sums[1:])
    lb2 = column_sums[1] + min(lign_sums[:1] + lign_sums[2:])
    lb3 = column_sums[2] + min(lign_sums[:2] + lign_sums[3:])
    lb4 = column_sums[3] + min(lign_sums[:3] + lign_sums[4:])
    lb5 = column_sums[4] + min(lign_sums[:4] + lign_sums[5:])

    return max(lb1, lb2, lb3, lb4, lb5)
def first_LBA (processing_times,jobs,column_sums) :
    first_job=jobs[0]
    matrix =  processing_times[:, 1:]
    matrix = np.delete(matrix, jobs[0], axis=0)
    row_sums = np.sum(matrix, axis=1)
    lb1=column_sums[0] +np.min(row_sums)
    matrix =  matrix[:, 1:]
    row_sums = np.sum(matrix, axis=1)
    lb2=column_sums[1]+processing_times[first_job,0]+np.min(row_sums)
    matrix =  matrix[:, 1:]
    row_sums = np.sum(matrix, axis=1)
    lb3=processing_times[first_job,0]+processing_times[first_job,1]+column_sums[2]+np.min(row_sums)
    matrix =  matrix[:, 1:]
    row_sums = np.sum(matrix, axis=1)
    lb4=processing_times[first_job,0]+processing_times[first_job,1]+processing_times[first_job,2]+column_sums[3]+np.min(row_sums)

    lb5=processing_times[first_job,0]+processing_times[first_job,1]+processing_times[first_job,2]+processing_times[first_job,3]+column_sums[4]

    return max(lb1,lb2,lb3,lb4,lb5)
def LBA (processing_times,jobs,column_sums) :

    matrix =  processing_times[:, 1:]

    # Create a matrix without the jobs exist in the jobs list
    mask = np.ones(len(matrix), dtype=bool)
    mask[jobs] = False
    matrix = matrix[mask]
    #-------------------------------------------------------
    #
    row_sums = np.sum(matrix, axis=1)
    M =job_completion_times(processing_times, jobs)
    #---------------------lb1
    lb1=column_sums[0] +np.min(row_sums)


    #---------------------lb2

    lb2=M[len(jobs)-1,1]+np.sum(matrix[:, 0])
    matrix =  matrix[:, 1:]
    row_sums = np.sum(matrix, axis=1)
    lb2=lb2+np.min(row_sums)
    #---------------------lb3

    lb3=M[len(jobs)-1,2]+np.sum(matrix[:, 0])
    matrix =  matrix[:, 1:]
    row_sums = np.sum(matrix, axis=1)
    lb3=lb3+np.min(row_sums)
    #---------------------lb4
    lb4=M[len(jobs)-1,3]+np.sum(matrix[:, 0])
    matrix =  matrix[:, 1:]
    row_sums = np.sum(matrix, axis=1)
    lb4=lb4+np.min(row_sums)
    #---------------------lb5
    lb5=M[len(jobs)-1,4]+np.sum(matrix[:, 0])



    return max(lb1,lb2,lb3,lb4,lb5)
def branch_and_bound(processing_times, initial_solution, initial_cost):
  import numpy as np
  import matplotlib as plt
  from typing import List
  import itertools
  import time
  import math
    column_sums = [sum(col) for col in zip(*processing_times)]
    jobs, machines = processing_times.shape
    root_node = Node([], set(range(jobs)))
    best_solution = initial_solution.copy()
    best_solution_cost = initial_cost

    def dfs(node):

        nonlocal best_solution, best_solution_cost
        if ((len(node.jobs)!=0 and node.lower_bound < best_solution_cost) or (len(node.jobs)==0)):
            # Calculate the lower bounds for all remaining jobs
            lower_bounds = []
            for job in node.remaining_jobs:
                child_jobs = node.jobs + [job]
                child_remaining_jobs = node.remaining_jobs - {job}

                # Calculate the lower bound for the child node
                ev = evaluate_sequence(child_jobs, processing_times)
                if not child_remaining_jobs:
                    child_lower_bound = ev
                else:
                    child_lower_bound = LBA(processing_times, child_jobs, column_sums)

                if not child_remaining_jobs and job == max(node.remaining_jobs):
                    if child_lower_bound < best_solution_cost:
                        best_solution = child_jobs
                        best_solution_cost = child_lower_bound
                        print('new best solution', best_solution)
                        print('new best cost', best_solution_cost)
                    continue

                # If the child node is not a leaf, continue the depth-first search
                if child_lower_bound < best_solution_cost:
                    child_node = Node(child_jobs, child_remaining_jobs, parent=node, lower_bound=child_lower_bound)
                    lower_bounds.append(child_node)

            # Sort the child nodes based on their lower bounds
            sorted_nodes = sorted(lower_bounds, key=lambda x: x.lower_bound)
            for sorted_node in sorted_nodes:
                dfs(sorted_node)

    # Start the depth-first search with the root node
    dfs_stack = [root_node]
    i = 0
    while dfs_stack:
        current_node = dfs_stack.pop()
        dfs(current_node)
        i += 1

    return best_solution, best_solution_cost, i